{
    "result": {
        "lfcch": "",
        "rtinmz": "The optimized solution is a bit vague, the normal solution is easy tho.",
        "sbstii": "Hard Problem",
        "mtrixmdin": "Binary Search Optimal Solution is Hard. Didn't get it, Revisit later as well.",
        "dd2nmbrsinll": "The video explanation answer is simple, follow that not the article one.",
        "pstrdrtrvrsl": "Most Optimal Solution has a concept that we have to remember.",
        "rvrsllrcrsiv": "Easy:- Recursive mein see how we are changing pointers.",
        "ditdistncdp33": "Explains prev and cur ka concept nicely.",
        "srchin2dmtrix": "For a matrix of n*m\n\nWhile applying Binary Search.\n\nrow = mid/m\ncolumn = mid%m",
        "tplgiclsrtbfs": "Easy but has a concept to remember, see the outer video and not the video inside the page.",
        "tplgiclsrtdfs": "Easy but has a concept to remember, see the outer video and not the video inside the page.",
        "implmntminstck": "EASY: But, In Optimal Solution we need to see the formula that is being derived during push and pop.",
        "kthprmttinsqnc": "Medium Problem",
        "lftviwfbinrytr": "Easy question, with a concept to remember.",
        "mdinf2srtdrrys": "Easy - Mediumish Problem, but has a concept to remember.",
        "mstsingprimslg": "See MST Video from the playlist first\n\n\n\nMatrix:-\n\nint[][] edges = {\n    {0, 1, 2},\n    {0, 2, 1},\n    {1, 2, 1},\n    {2, 3, 2},\n    {3, 4, 1},\n    {4, 2, 2}\n};\n\n\nAdj List:-\n\n0: [(1, 2), (2, 1)]\n1: [(2, 1)]\n2: [(3, 2)]\n3: [(4, 1)]\n4: [(2, 2)]\n\nEach line corresponds to a node in the graph, and the values within the square brackets represent the adjacent nodes along with the edge weights.\n\nHere's the adjacency list in a more organized format:\n\nNode 0 is connected to nodes 1 (weight 2) and 2 (weight 1).\nNode 1 is connected to node 2 (weight 1).\nNode 2 is connected to node 3 (weight 2).\nNode 3 is connected to node 4 (weight 1).\nNode 4 is connected to node 2 (weight 2).",
        "dijkstrslgrithm": "This question has 3 previous problems attached to it, please study those during revision.",
        "mstsingkrsklslg": "See Disjoint Set video from the playlist first.\n\nNeeds Special Attention, HARDEST of everything, Yet Doable with practice.",
        "mxwidthfbinrytr": "Easy - Mediumish Question, revisit the logic while revision.",
        "nbnddknpsckdp23": "Working of Space complexity i.e. from two arrays => prev and cur to only one array => prev is shown in this video.",
        "ninjstriningdp7": "Mediumish...",
        "mrrisinrdrtrvrsl": "Easy, just see the approach.",
        "byndsllstckiidp36": "It has the 4th level of optimization, with 2 variables, do revise.",
        "findlcftwndsinbst": "Easy question, just see the logic.",
        "kthlmntf2srtdrrys": "Similar to the above question.",
        "minimmdystmkmbqts": "Easy concept but see the Possible() logic..",
        "plindrmprtitining": "Mediumish problem / See C++ code explanation for more clarity.",
        "kthlmntftwsrtdrrys": "Same as the previous code, with very few changes.",
        "distinctsbsqncsdp32": "Good explanation of space optimization ka optimization.",
        "lngstcmmnsbsqncdp25": "Note\nRemember:-\n\nThe Function call for:-\n\nf(2,2) represents -> LCS of String 1(0...2) and LCS of String 2(0...2)\nor\nf(2,5) represents -> LCS of String 1(0...2) and LCS of String 2(0...5)\n\nAnd the function f will return us the maximum value between both the LCSs of String 1 and String 2.\n\nSimilarly:-\n\nf(n,m) represents -> LCS of String 1(0...n) and LCS of String 2(0...m)",
        "lngstincrsingsbsqnc": "Need more practice/ why do we need N X N matrix to store the dp.",
        "printprimfctrsfnmbr": "Easy but see the final approach, again",
        "binrytrtdbllinkdlist": "Easy but has logic to remember.",
        "chckifllisplindrmrnt": "Easy\n\nContains :-\n\n1. Middle Element\n2. Reversing 2nd half.\n3. Comparing 1st and 2nd half\n4. Re-Reversing",
        "kthmissingpsitivnmbr": "Binary Search Solution is Different see it during revision.",
        "lrgstrctnglinhistgrm": "The most optimized approach (3rd approach) is of Medium Type and needs attention during revision, 1st and 2nd approaches are easy tho.",
        "vltblnxprssinttrdp52": "Little different problem, Mediumish.",
        "chckfrchildrnsmprprty": "Easy question, but revisit the logic.",
        "mximmxrftwnmbrsinnrry": "Easiesh yet a little different.",
        "findkthsmllstlmntinbst": "Easy - Mediumish question, see code explanation from here:- https://youtu.be/Zra0mE7M2hE",
        "flttnbinrytrtlinkdlist": "Easy, just see how to do it.",
        "3ddpninjndhisfrindsdp13": "Space Optimised code Mediumish...",
        "lngstincrsingsbsqncdp43": "NOTE:- With this method, we only get the length of LIS and not the LIS itself, for LIS you can refer to previous solutions,\n\nThis solution helps us to find the LIS with better time complexity only.\n\nNOTE 2:- The generated temp array's length is what matters as we are re-writing it. That array does not contain LIS.\n\n=================================\n\nNOTE FOR THE CODE PART:- binarySearch(int[] a, int fromIndex, int toIndex, int key): Searches a specified range [fromIndex, toIndex) in the array a for the key.\n\nThe Arrays.binarySearch function in Java returns the index of the element if it is found in the array. If the element is not found, it returns a negative value that represents the insertion point.\n\nint[] arr = {2, 5, 8, 12, 16};\nint key = 7;\nint index = Arrays.binarySearch(arr, key);\n\nIn this example, key is not found in the array, and binarySearch returns the insertion point, which is -4. This means that key should be inserted at index 4 to maintain the sorted order. However, keep in mind that this insertion point is 1-based; it suggests that the element should be inserted just before the element at index 4 (which is 12). So, index represents the position where key should be inserted, which is 3.\n\n=================================\n\nCode:-\n\nimport java.util.Arrays;\n\npublic class Main {\n\npublic static int longestIncreasingSubsequence(int[] arr, int n) {\n        int[] temp = new int[n];\n        int len = 1;\n\n        temp[0] = arr[0];\n\n        for (int i = 1; i < n; i++) {\n            if (arr[i] > temp[len - 1]) {\n                temp[len++] = arr[i];\n            } else {\n                int ind = Arrays.binarySearch(temp, 0, len, arr[i]);\n                if (ind < 0) {\n                    ind = -(ind + 1);\n                }\n                temp[ind] = arr[i];\n            }\n        }\n        return len;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {10, 9, 2, 5, 3, 7, 101, 18};\n        int n = arr.length;\n\n        System.out.println(\"The length of the longest increasing subsequence is \" +\n                longestIncreasingSubsequence(arr, n));\n    }\n}",
        "lngststringwithllprfixs": "class TrieNode {\n    TrieNode[] links;\n    boolean isEnd;\n\n    public TrieNode() {\n        links = new TrieNode[26];\n        isEnd = false;\n    }\n\n    public boolean containsKey(char ch) {\n        return links[ch - 'a'] != null;\n    }\n\n    public TrieNode get(char ch) {\n        return links[ch - 'a'];\n    }\n\n    public void put(char ch, TrieNode node) {\n        links[ch - 'a'] = node;\n    }\n\n    public void setEnd() {\n        isEnd = true;\n    }\n\n    public boolean isEnd() {\n        return isEnd;\n    }\n}\n\nclass Trie {\n    private TrieNode root;\n\n    public Trie() {\n        root = new TrieNode();\n    }\n\n    public void insert(String word) {\n        TrieNode node = root;\n        for (int i = 0; i < word.length(); i++) {\n            char ch = word.charAt(i);\n            if (!node.containsKey(ch)) {\n                node.put(ch, new TrieNode());\n            }\n            node = node.get(ch);\n        }\n        node.setEnd();\n    }\n\n    public boolean checkIfAllPrefixExists(String word) {\n        TrieNode node = root;\n        boolean flag = true;\n        for (int i = 0; i < word.length() && flag; i++) {\n            char ch = word.charAt(i);\n            if (node.containsKey(ch)) {\n                node = node.get(ch);\n               if(node.isEnd() == false) return false;\n            } else {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\npublic class Solution {\n    public String completeString(int n, String[] a) {\n        Trie obj = new Trie();\n        for (String word : a) {\n            obj.insert(word);\n        }\n        String longest = \"\";\n        for (String word : a) {\n            if (obj.checkIfAllPrefixExists(word)) {\n                if (word.length() > longest.length()) {\n                    longest = word;\n                } else if (word.length() == longest.length() && word.compareTo(longest) < 0) {\n                    longest = word;\n                }\n            }\n        }\n        if (longest.equals(\"\")) {\n            return \"None\";\n        }\n        return longest;\n    }\n}",
        "minimizmxdistnctgssttin": "Mediumish-Hard",
        "plindrmprtitiningiidp53": "Uses Front Partition.",
        "prtitinrryfrmximmsmdp54": "Uses Front Partition.",
        "sizfthlrgstbstinbinrytr": "Easy - Mediumish, has a logic to remember.",
        "cnstrctbstfrmprrdrtrvrsl": "Easy, but remember the concept.",
        "mximmrctnglrwithll1sdp55": "Isska jo linked solution hai(CORE CODE), vo thoda MEDIUMISH hai.....(Ussme v jo sbse optimized solution h vo MEDIUMISH h(Part-2), Jo Brute and Usse Optimal Solution hai(Part-1) vo EASY hi h.",
        "byndsllstckswithcldwndp39": "This has 3 variables used for optimization.",
        "printllprmttinsfstringrry": "1st approach is Medium, Swap Approach is easy and didn't try Backtrack Solution...",
        "dtctcyclindirctdgrphsingbfs": "See directly from the playlist.",
        "dtctcyclindirctdgrphsingdfs": "See directly from the playlist.",
        "nmbrfislndsdingridndgrphbth": "Easy - medium-ish problem, has a concept to remember.",
        "minimmpthsmintringlrgriddp11": "Little different, just see. EASY - MEDIUMISH",
        "srtllf0s1snd2sbychnginglinks": "Burteforce is easy, and the optimal approach is Easy - Medium but has an approach to remember.",
        "cnstrctbinrytrfrminrdrndprrdr": "Mediumish Code, revisit properly during revision.\n\nPS:- PostOrder has a better explanation, better see that first.",
        "nmbrflngstincrsingsbsqncsdp47": "Mediumish Question. Revisit again.",
        "cnstrctbinrytrfrminrdrndpstrdr": "Similar to the previous question. Mediumish problem.\n\nThis has a better explanation, see it first before PreOrder.",
        "SearchRowColumnWiseSortedMatrix": "Similar to the previous question we need to remember the start point for the optimised solutions.",
        "printinglngstincrsingsbsqncdp42": "Needs attention while revising..... Mediumish - Has concept to remember...",
        "prtitinstint2sbstswithminbsltsmdiffdp16": "Important tabulation DRY run is explained in this video.",
        "minimmpthsmingriddp10": "test note update"
    }
}